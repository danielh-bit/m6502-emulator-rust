==== ASSEMBLER ====
State: will take a string input of txt file and convert the txt to a hexadecimal array that will be fed to the eeprom.

== Main Stages ==
	1. Input is fed to *Lexer. The lexer will turn the input into a more tokenized and easier to work with input.
	2. Lexer input is proccessed in the assembler and compiled into binary.
	3. Binary is returned to main to written to eeprom.
						==== END ====
	
	=== LEXER ===
	The lexer will take the raw string input from the file and designate input into catogories based on certian conditions. 
	Example: If the first char of a line is tab or space it will designate that line into a "Command" catorgie. If a space
	or tab is not found then the line will be designated as a "Label" and will be sent as a special code for the assembler 
	to interpret.
		== Token Branches == ('_' before token signifies that the following is input)
		1. Commands
			a. macro - currently not supported for reasons.
				i. _type
			b. instruction
				i. _immidate addressing
				ii. _zeropage (x and y)
				iii. _absolute (x and y)
				iv. _indirect (x and y)
				v. _ implied ;depends on instruction.
				vi. _ relative
		2. Labels
			a. _variables
			b. program memory positions. (are written only when assembled)

		** SPECIAL CASES **
			if ';' is met anywhere through the process, the loop will skip to next line.

		== Token Convertion ==
		1. assemble determined
		2. user determined.
		- Instructions: will be converted into their final hexadecimal form based on input.
		- Labels: will be assigened to a negative number. Each time the assembler will meet a negative number he will
		  convert it into its appropriate data. Example: The first label the tokenizer will meet be assigened -1, second -2 
		  and so on. If the label is a veriable than its value will be changed by switching the sign to be negative.
		  When the assembler will meet a negive input from the lexer it will check if the next input is also negative. If
		  not then the value is a program counter position and will be treated appropriatly. If the next input wil be a 
		  negative number then the assembler will know that it is a veriable and will replace all the next instances of that
		  variable label with the value (sign inverted back to postive). The instantion of a function label will be saved as
		  an even number and the call for that label will be an odd number. Example: loop will be instantioted with -2 but called
		  with -1. (always -1 from instantion value).

		  todo: fix absolute (crosspage). make ASL more modular. Add all instructions that manipulate mem.
			after fixes and debugging:
		  V - make clock for cycles
		  V - make PORTS...
			- make kernal for pc
			- make iterface for pc
			- make macros for assembler
			- clean the m6502 instruction match... (if possible)
		  V - implment different modules that can be added

==== Memory Configuration ====
	== Designated Space ==
	- EEPROM: 0x8000-0xffff
	- RAM: 0x100-0x3ff
	- HEAP: 0x6000-0x7fff (still needs to be added)

=== FUNCTION LABEL FIX ===
X   1.To do this I'll need to count the binary size (means excluding the instantions of labels), then I'll use the new
	  clean vector to define the locations of the labels based on the info
V   2.Make an intermidate form of the vec (this will exclude the instantiations). The label HashMap will contain the instance value
	  and a vector including all the codes in that label until the next label or the end of the program. The label locations will be
	  defind if the a match between the label code value and the code is found. The location will be the location of the first
	  instuction of that vector. Algorithem:
			== Make Intermidate Lex Code form ==
				- make Inter_vec
				- iter through the lex_codes: if label instance don't add, else add
			== Make the HashMap ==
				- Make temp vec
				- Look for a negative even number (label instance).
				- Start adding the codes to a vec if the code isn't a label instance.
				- when a label instance is found: Insert the previous instance found and the vector that was created. Clear vector and init label instance.
				- when reached end add the last vector to the last label.
			== Find Label Locations ==
				- make temp vec
				- make temp location of first instuction
				- add code to vec
				- Go through all the labels and check if they contain that vec.
					YES: Insert label value and the location of the first instuction. Clear the location of the first intruction clear temp vec.
					NO: add code to vec.
				- if when reached end the temp vec is not empty crash.
			== NORMAL ==
			go through the inter_vec and replace all negative numbers (label calls) with their location. If not contains crash. check if branch to do
			branch case. Make binary.
	  CONS:
		- Very slow, a lot of loops. Can save all the label contains loops in part 3 with: instead of adding all instuctions to a vec, make a counter
		  between labels and add the counter to the label HashMap. Use that to calculate the position of every label by adding the offsets of all previous
		  labels before the call.  
		- When adding jump for special branch case it'll break all label locations after the branch. To solve this the rest of the binary will be made
		  with the label locations offsetted by 6.

=== MEMORY MODULES ===
	Memory modules are the tools for the cpu to interact with world. To read a keyboard input it will read a location in memory where the input will be
	stored. The memory modules should be 100% configurable and generic. The way that the cpu will interact with memory: The cpu can either read or write 
	to memory, if the instuction will be of type read - the cpu will try to read from the location. If read is not-seccessful (if the module is not 
	configured for reading, the CPU will read a garbage value [RND]). Bye peek (read) or poke (write) the CPU will be able to access all the modules and 
	use them to achieve full PChood. The modules could be RAM, EEPROMS, KEYBOARDS, SCREENS...
	== Memory Configuration ==
		Memory will be built of the following fields:
			- SIZE: u16
			- START_LOCATION: u16
			- TRAITS: Vec<MemoryTrait>
		== Designated Space ==
			- EEPROM: 0x8000-0xffff
			- RAM: 0x100-0x1ff

==== MACROS ====
	LIST:
	 - .org: sets the the starting location for the CPU to read the program (DOES NOT SET THE LOCATION OF THE EEPROM WRITE, the org needs to be 
	   aligned with the first location of the memory chip). Labels cannot be used for it because it needs to be the first instuction on the asm.

== UPDATES ==
	- Added ASL to instuction set
	- Added ASL to assebmler

== UI ==
	The UI will need to have the following functionality: An interface that will be able to show all the registers in hex (or other formats
	if needed). access to the console. access to all programms in the file and a text editor. at the press of a button you should be able
	to activate the command prompt, switch to program start with the screen running. The command prompt is an integral part and should
	be at at the bottom of the screen. to access the command prompt the user will input ';' and to exit he will input either 'enter' to
	register the command or 'esc' to escape. to enter the runtime mode prompt >> "run -*command configuration" example: "run -W" to
	run with the screen on.

== FIXING THE LABEL ALGORITHEM (speed) ==
	Throw the lexer away and do label computation in real time. This will remove a lot of uneeded complexity
	and will speed up the algorithem. This should remove 3 uneeded loops and simplfy the algorithem to 
	make it more readble.
	= STEPS =
		1. Make all the label computation in the Lexer struct:
			= General Idea = 
				when label is detected (in label loop): add label to  -redacted-HashMap<String (name), Vec<i32> (positions)>.
				in main loop: if label initialization is detected - find tokens.len() and set all the calls to that label
				to the tokens.len(). problem: how to use label after? solution: make label struct - name, positions, initialized
				instead of HashMap make a vec of Label struct. if initialized is true the position of the label will be in positions[0]
				(will be good to make a method in the struct for doing that automatically, optimally with option). problem: how to
				use contains on name. solution: intead of label vec make label HashMap<String (name), Label>.
				if label is called on: if label is intialized - get positions[0] from label. else add position of the call to positions
				*special cases: branch instructions - make a method to find out if overloaded.
				if overloaded: push all the nessesary instructions as in current version. make a branch overloaded variable,
				set it true in this case. when a label call is made: check if overloaded and add 6*overloaded to position.
				if not overloaded: just push position.
				problem: Only instuctions after the branch need to be offsetted by 6 if overloaded. solution: search through
				all the labels and check if intialized position is after the branch overload, add 6*overloaded to positions[0].
				add 6*overloaded to all the uninitialized labels that will be called upon. In this approach, 6*overloaded
				should be added to any position of value of label.
			= Tests Progarmms = 
				These are the test programms that need to be passed for production:
				1. simple label init and call after.
				2. call before init.
				3. simple branch instruction.
				4. branch overload for a label init before.
				5. branch overload for a label init after.
				6. branch for different amounts of overload before and after.
		2. Dislocate the Lexer struct by moving all methods into the Assembler struct.
		3. Delete assembler method and move all functionallity to lex method under assembler name. 
		E. results
	current assembly for fibonachi-infinite: 360-120 [micro seconds]
	after optimization: 